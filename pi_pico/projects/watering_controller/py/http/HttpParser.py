# HttpParser.py

###@@@ how to tell if you are on a Pico or something else
###@@@ os.name, sys.platform, or platform.system().

import sys
from http.ParsedHttp import ParsedHttp, METHOD_NAMES
from utils import *

class HttpParser:
    """ parses HTTP replies
    """

    def __init__(self):
       """ """
       self._latest_error = ""


    def latest_error(self):
        return self._latest_error

    def parse_header_data(self, hdr_data):
        """ Parse HTTP header.
        Arg hdr_data is string (decoded bytes from HTTP message)
        Returns ParsedHttp obj if ok; None if failed (in which case
        see the ph.latest_error() flag(??NOTYET??) as well as 
        this-parser.latest_error().
        """

        dbg(f"HP.parse_header_data  >>>>  {"NO-DATA" if hdr_data is None else len(hdr_data)}")

        self.no_err()

        if hdr_data is None:
            ###self.err(l no(), f"Header Data is NONE")
            self.err(f"Header Data is NONE")
            return None

        eol_sep = "\r\n"
        if hdr_data.find(eol_sep) < 0:
            eol_sep = "\n"
            if hdr_data.find(eol_sep) < 0:
                self.err(f"CANNOT DETERMINE eol-sequence")
                dbg(f"HttpParser.parse_header_data {self._latest_error}")
                return None
        dbg(f"HttpParser.parse_header_data expected eol: {repr(eol_sep)}")

        # NOTE the split causes an 'extra' empty line - containing the 'nothing'
        # after the last eol_sep.
        # AND there should be an explicit blank line at the end of the header.
        lines = hdr_data.split(eol_sep)

        dbg(f"HttpParser.parse_header_data SPLIT LINES {len(lines)=}  ")

        if len(lines) < 3:
            ###dbg(f"HttpParser.parse_header_data ONLY {len(lines)} HEADER LINE(S) FOUND after splitting on eol {repr(eol_sep)}")
            self.err(f"ONLY {len(lines)} HEADER LINE(S) FOUND after splitting on eol {repr(eol_sep)}")
            dbg(f"HttpParser.parse_header_data {self._latest_error}")
            return None

        print(f"@@@HP@62 lines are {lines}")

        # There should be the empty line from the header plus the
        # extra end of line generated by doing split()
        last_line = lines[-1]
        second_to_last_line = lines[-2]
        if len(last_line) != 0:
            self.err(f"Expected blank last line; got '{last_line}'")
            return None
        if len(second_to_last_line) != 0:
            self.err(f"Expected blank second-to-last line; got '{second_to_last_line}'")
            return None
        print(f"@@@HP@74 found empty line end-of-hdr")

        start_line = lines[0]
        fields_lines = lines[1:-2]

        ph = ParsedHttp()

        ok = self.parse_start_line(ph, start_line)
        dbg(f"HP@82 parse_start_line  {ok=}")
        if not ok: 
            if not self._latest_error:
                err(84, "INTERNAL ERROR start-line parse failed but no _latest_error")
            return None

        for line in fields_lines:
            err_stg = self.parse_element_line(ph, line)
            if err_stg:
                self.err(f"Cannot parse field-line '{line}'  Error:{err_stg}")
                return None

        return ph


    def parse_start_line(self, ph, start_line):
        """ Parse the start line (first line of header):
            Request ex: GET / HTTP/1.1
                        POST /api/users HTTP/1.1
            Reply ex: HTTP/1.0 200 OK 
        Returns True-y if ok, False-yNone if error.
        """
        ###dbg(f"parse_start_line@{lno()}  {start_line=}  ph={ph}")
        dbg(f"parse_start_line@105  {start_line=}  ph={ph}")

        self.no_err()
        if self.parse_request_start_line(ph, start_line):
            return True

        self.no_err()
        if self.parse_reply_start_line(ph, start_line):
            return True

        self.err(114,f"FAILED TO PARSE START LINE '{start_line}'")
        return False


    def parse_request_start_line(self, ph, start_line):
        """ Parse the start line of a Request. ie the first line:
            Request ex: GET / HTTP/1.1
                        POST /api/users HTTP/1.1
        """
        dbg(f"HP@121 {start_line=}")

        parts = start_line.split()
        dbg(f"HP@124 parts={parts}")
        if len(parts) < 3:
            self.err(128, f"Reply start line: only {len(parts)} parts, expected 3:  {start_line}")
            return False
        
        method_stg = parts[0]
        request_url = parts[1]
        version_stg_val  = parts[2]
        dbg(f"hrp@132 {method_stg=}  {request_url=} {version_stg_val=}  ")

        if method_stg not in METHOD_NAMES:
            self.err(137, f"Action '{method_stg}' is not in {METHOD_NAMES}")
            return False

        got_version = self.parse_http_version(version_stg_val)

        dbg(f"hrp@143  {got_version=}")
        if not got_version:
            return None

        parsed_url = self.parse_url(request_url)
        dbg(f"hp@147  {parsed_url}")
        if not parsed_url:
            self.err(148, f"Failed to parse url '{request_url}'")
            return False
        url_path, url_query_params, url_bookmark = parsed_url

        ph.set_as_request(method_stg, request_url, 
                          url_path, url_query_params, url_bookmark, 
                          got_version)
        return True


    def parse_reply_start_line(self, ph, start_line):
        """ Parse the start line of a Reply. ie the first line:
            Reply ex: HTTP/1.0 200 OK 
            Returns the True-y if ok, None if not - so check latest_error().
        """
        parts = start_line.split()
        dbg(f"parse_reply_start_line parts={parts}")
        if len(parts) < 3:
            self.err(f"Reply start line: only {len(parts)} parts, expected 3:  {start_line}")
            return None
        
        version_stg_val = parts[0]
        numeric_code_val = parts[1]
        reply_stg_val  = parts[2]
        dbg(f"hrp@171 {version_stg_val=}  {numeric_code_val=}  {reply_stg_val=}  ")

        got_version = self.parse_http_version(version_stg_val)

        dbg(f"hrp@143  {got_version=}")
        if not got_version:
            return None

        num_code_as_int = string_to_int(numeric_code_val)
        dbg(f"hrp@142 {num_code_as_int=}")
        if num_code_as_int <= 0:
            self.error(lno(), f"Reply numeric_code is not an int or is less than zero: {numeric_code_val}")
            return None
        got_num_code = str(num_code_as_int)

        ph.set_as_reply(got_version, got_num_code, reply_stg_val)

        return True


    def parse_http_version(self, ver):
        """ Arg is "HTTP/1.1" or such "
        Returns "1.1" or None if not parse-able
        """
        parts = ver.split("/")
        if len(parts) != 2:
            self.err(185,f"WRONG NUMBER OF PARTS: {len(parts)} in 'HTTP' version string: '{ver}'")
            return None
        http_part = parts[0]
        version = parts[1]
        dbg(f"HP.parse_http_version@175 http_part {http_part}  version {version}")
        if http_part not in ("HTTP", "http"):
            self.err(177,f"UNKNOWN 'HTTP' part. version string: '{ver}'")
            return None
        if len(version) <= 0:
            self.err(194,f"VERSION part missing. 'HTTP' version string: '{ver}'")
            return None
        return version


    def parse_element_line(self, ph, line):
        """ parse lines like:
       "Server: SimpleHTTP/0.6 Python/3.12.3",
       "Date: Sat, 07 Feb 2026 01:36:36 GMT",
       "Content-type: image/vnd.microsoft.icon",
       "Content-Length: 15086",
       "Last-Modified: Fri, 06 Feb 2026 02:51:34 GMT"
        Returns False-y if ok, returns error-string if any error.
        """

        dbg(f"@@@ elt line '{line}'")
        if len(line) < 3:
            e = f"HttpParser.parse_element_line@185 Field-value line too short. len={len(line)}  line='{line}'"
            return e

        # split into 2 parts: keyword and value
        parts = line.split(":", 1)
        dbg(f"@@@ parts {parts}")

        field_name = parts[0]
        #@@@@@@@@@@@@ should we strip? or leave the whitespace????
        field_value = parts[1].strip()

        try:
            ph.add_field(field_name, field_value)
        except ValueError as ex:
            return f"HttpParser.parse_element_line Error in field {line}. ex={ex}"
        return ""

    def parse_url(self, full_url):
        """ https://blog.example.com:443/page.html?id=10#section
        Scheme: https  Subdomain: blog  Domain: example.com  Port: :443
        Path: /page.html  Query: ?id=10  Fragment: #section 
        """
        # assumes we have just the 'page.html?...#...' part
        url_stg = full_url

        parts = url_stg.rsplit("#")
        dbg(f"@@243 parts[#]  {parts}")
        frag = ""
        if len(parts) > 1:
            frag = parts[1]
            url_stg = parts[0]
        dbg(f"@@@250  {frag=}  {url_stg=}")

        parts = url_stg.rsplit("?", 1)
        dbg(f"@@253 parts[?]  {parts}")
        
        if len(parts) > 1:
            path = parts[0]
            query = parts[1]
        else:
            path = url_stg
            query = ""
        dbg(f"@@@261  {path=}  {query=}")

        query_parts = query.split("&")
        dbg(f"@@253 parts-of-query  {query_parts}")

        query_params = {}
        for qitem in query_parts:
            dbg(f"@@ 267 {qitem=}")
            parts = qitem.split("=",1)
            dbg(f"@@@270 Qparts {parts}")
            qkey = parts[0]
            qval = ""
            if len(parts) > 1:
                qval = parts[1]
            query_params[qkey] = qval
        dbg(f"@@@276  {query_params}")
    
        return (path, query_params, frag)

    def unquote_url(self, url):
        # replace %20 or plus-sign with space
        # %0A with newline, etc
        url = url.replace(r'%20', ' ')
        url = url.replace(r'+',   ' ')
        url = url.replace(r'%0A', '\n')
        url = url.replace(r'%25', '%')
        url = url.replace(r'%23', '#')
        url = url.replace(r'%26', '&')
        url = url.replace(r'%2F', '/')
        url = url.replace(r'%3F', '?')
        url = url.replace(r'%3D', '=')
        url = url.replace(r'%3A', ':')
        url = url.replace(r'%2B', '+')
        url = url.replace(r'%2C', ',')
        url = url.replace(r'%22', '"')
        url = url.replace(r'%3C', '<')
        url = url.replace(r'%3E', '>')
        url = url.replace(r'%5B', '[')
        url = url.replace(r'%5D', ']')
        return url

    # def err(self, err_stg):
        # self._latest_error = f"HttpParser.parse_element_line: {err_stg}"

    def no_err(self):
        self._latest_error = ""

    def err(self, line_no, err_stg=None):
        if err_stg is None:
            err_stg = line_no
            line_no = ""
        else:
            line_no = "@" + str(line_no)
        self._latest_error = f"HP{line_no} {err_stg}"


### end ###
